"""
    id посылки - 69819836

        -- ПРИНЦИП РАБОТЫ –-
    1. Разворачиваем все ребра "B" в обратную сторону
    2. Ищем цикл -> если находим - карта не оптимальная

        -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ –-

    При развороте путей данные графы будут являться турнирами (каждая из вершин соединена одной направленной дугой)
    => 
        Любой турнир с конечным числом n вершин содержит гамильтонов путь (https://ru.wikipedia.org/wiki/Гальминотов_граф),
    то есть ориентированный путь, содержащий все n вершин. 
        Это легко показать с помощью математической индукции по n: 
    пусть утверждение верно для n, и пусть имеется некий турнир T с n+1 вершинами. 

        Выберем вершину v0 в T и пусть {v1,v2...vn} — направленный путь в T\{v0}. 

        Пусть i, (i<=0<=n) — максимальное число такое, что для любого j<=i имеется дуга из vj в v0.
         Тогда v1,..., vi, v0, vi+1, ..., vn  — искомый ориентированный путь. 
    Это доказательство даёт также алгоритм поиска гамильтонова пути. Известен более эффективный алгоритм, требующий перебора всего O(n logn) дуг.

    Более строго: любой сильно связанный турнир является вершинно панциклическим — 
 для любой вершины v и для любого k от трёх до числа вершин в турнире имеется цикл длины k,
содержащий v. Более того, если турнир 4-связен, любая пара вершин может быть соединена гамильтоновым путём.

    Это означает, что строго связный турнир имеет цикл => чтобы найти ответ, необходимо найти хотя-бы один цикл

    При запуске dfs() будем присваивать городам индексы:
        0: не посещенный город
        1: посещенный, но не все ребра обработаны
        2: посещен, и ребра обработаны
    
    При условии: по дорогам можно двигаться только от города с меньшим номером к городу с большим номером.
 
    Карта железных дорог называется оптимальной, если не существует пары городов A и B такой,
     что от A до B можно добраться как по дорогам типа R, так и по дорогам типа B.
    Пусть в построенном графе существует цикл An, An+1, ... An+i, ... An. Следовательно, по построению,
    существует пара Aj, Ak такая, что Ak < Aj (реверсивное ребро), следовательно, существует пара Aj, Ak городов
    такая, что от Ak до Aj можно добраться как по дорогам типа B, так и по дорогам типа R => карта дорого не оптимальна 
    => циклы в данном графе являются признаком неоптимальности
 
    Ak ---- B ----> An ---- B ----> An+i ---- B ----> Aj
    |                                                  |
    Ak ====================== R ====================> Aj
 
    Таким образом, если в процессе dfs() мы наткнемся на серый город, это будет означать,
    что существует пара городов, между которыми есть маршрут с разным типом дорог и
    карта железных дорог в этом случае является не оптимальной. 

    Цикл в турнире - https://ru.wikipedia.org/wiki/%D0%A2%D1%83%D1%80%D0%BD%D0%B8%D1%80_(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2)
    Поиск циклов - https://neerc.ifmo.ru/wiki/index.php?title=Использование_обхода_в_глубину_для_поиска_цикла 

        -- ВРЕМЕННАЯ СЛОЖНОСТЬ –-

    Асимптотика поиска цикла совпадает с асимптотикой поиска в глубину — O(|V|+|E|)

        -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

    Граф - O(E*V) 
    Цвета - O(V)
    => O(E*V+V) ~ O(E*V)
"""
import sys
sys.setrecursionlimit(10**6)
graph = [[] for _ in range(int(input()))]
for i in range(len(graph)-1):
    s = input()
    for j in range(len(s)):
        if(s[j] == 'R'):
            graph[i].append((j+i+1))
        else:
            graph[j+i+1].append(i)
colors = [0]*len(graph)
def dfs(v):
    colors[v] = 1
    for u in graph[v]:
        if(colors[u]==0):
            dfs(u)
        if(colors[u]==1):
            return True
    colors[v]=2
def isCyclic():
    for i in range(len(graph)):
        if(colors[i]==0):
            if dfs(i):
                return 'NO'
    return 'YES'
print(isCyclic())
    
